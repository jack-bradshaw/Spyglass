package com.matthewtamlin.spyglass.processors.code_generation;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.util.HashSet;
import java.util.Set;

import javax.lang.model.element.ExecutableElement;

import static com.matthewtamlin.java_utilities.checkers.NullChecker.checkNotNull;
import static com.matthewtamlin.spyglass.processors.code_generation.CallerComponentBuilder.buildGetDefaultValueSpecFor;
import static com.matthewtamlin.spyglass.processors.code_generation.CallerComponentBuilder.buildGetValueSpecFor;
import static com.matthewtamlin.spyglass.processors.code_generation.CallerComponentBuilder.buildShouldCallMethodSpecFor;
import static com.matthewtamlin.spyglass.processors.code_generation.CallerComponentBuilder.buildValueIsAvailableSpecFor;
import static com.matthewtamlin.spyglass.processors.code_generation.InvocationLiteralGenerator.getInvocationLiteral;
import static com.matthewtamlin.spyglass.processors.util.AnnotationUtil.getCallHandlerAnnotation;
import static com.matthewtamlin.spyglass.processors.util.AnnotationUtil.getDefaultAnnotation;
import static com.matthewtamlin.spyglass.processors.util.AnnotationUtil.getValueHandlerAnnotation;
import static com.matthewtamlin.spyglass.processors.util.ElementUtil.getTypeOfNonUseParameter;
import static javax.lang.model.element.Modifier.PUBLIC;

public class CompanionBuilder {
	private final ClassName targetClass;

	public static CompanionBuilder forTarget(final String packageName, final String className) {
		checkNotNull(packageName, "Argument \'packageName\' cannot be null.");
		checkNotNull(packageName, "Argument \'className\' cannot be null.");

		return new CompanionBuilder(ClassName.get(packageName, className));
	}

	public JavaFile generateCompanionFromElements(final Set<ExecutableElement> methods) {
		final Set<TypeSpec> callerSpecs = generateCallerSpecs(methods);

		return null; //TODO
	}

	private CompanionBuilder(final ClassName targetClass) {
		this.targetClass = checkNotNull(targetClass, "Argument \'targetClass\' cannot be null.");
	}

	private Set<TypeSpec> generateCallerSpecs(final Set<ExecutableElement> methods) {
		final Set<TypeSpec> callerSpecs = new HashSet<>();

		for (final ExecutableElement e : methods) {
			if (getCallHandlerAnnotation(e) != null) {
				callerSpecs.add(buildCallerForCallHandlerCase(e));

			} else if (getValueHandlerAnnotation(e) != null) {
				callerSpecs.add(
						getDefaultAnnotation(e) != null ?
								buildCallerForValueHandlerWithDefaultCase(e) :
								builderCallerForValueHandlerWithoutDefaultCase(e)
				);
			} else {
				throw new IllegalArgumentException("Argument \'e\' has neither a value handler " +
						"annotation nor a call handler annotation.");
			}
		}

		return callerSpecs;
	}

	private TypeSpec buildCallerForCallHandlerCase(final ExecutableElement e) {
		/* General anonymous caller structure

		new Caller {
			public void callMethod(T target, Context context, TypedArray attrs) {
				if (shouldCallMethod(attrs) {
					target.someMethod(use annotation values);
				}
			}

			public void shouldCallMethod(TypedArray attrs) {
				// Variable implementation, generated by CallerComponentBuilder class
			}
		}
		 */

		final MethodSpec shouldCallMethod = buildShouldCallMethodSpecFor(getCallHandlerAnnotation(e));

		final MethodSpec callMethod = getCallMethodPartialSpec()
				.addCode(CodeBlock
						.builder()
						.addStatement("if ($N(attrs))", shouldCallMethod)
						.addStatement("$L.$L", "target", getInvocationLiteral(e))
						.endControlFlow()
						.build())
				.build();

		return getCallerPartialSpec()
				.addMethod(callMethod)
				.addMethod(shouldCallMethod)
				.build();
	}

	private TypeSpec builderCallerForValueHandlerWithoutDefaultCase(final ExecutableElement e) {
		/* General caller structure without default

		new Caller {
			public void callMethod(T target, Context context, TypedArray attrs) {
				if (valueIsAvailable(attrs) {
					V value = getValue(attrs);
					target.someMethod(use annotation values);
				}
			}

			public void valueIsAvailable(TypedArray attrs) {
				// Variable implementation, generated by CallerComponentBuilder class
			}

			public V getValue(TypedArray attrs) {

			}
		}

		 */

		final MethodSpec valueIsAvailable = buildValueIsAvailableSpecFor(getValueHandlerAnnotation(e));

		final String nonUseParamType = getTypeOfNonUseParameter(e);

		final MethodSpec getValue = buildGetValueSpecFor(getValueHandlerAnnotation(e));

		final MethodSpec callMethod = getCallMethodPartialSpec()
				.addCode(CodeBlock
						.builder()
						.addStatement("if ($N(attrs))", valueIsAvailable)
						.addStatement("$T value = ($T) $N(attrs)", nonUseParamType, nonUseParamType, getValue)
						.addStatement("$L.$L", "target", getInvocationLiteral(e, "value"))
						.endControlFlow()
						.build())
				.build();

		return getCallerPartialSpec()
				.addMethod(callMethod)
				.addMethod(valueIsAvailable)
				.addMethod(getValue)
				.build();
	}

	private TypeSpec buildCallerForValueHandlerWithDefaultCase(final ExecutableElement e) {
		/* General caller structure with default

		new Caller {
			public void callMethod(T target, Context context, TypedArray attrs) {
				if (valueIsAvailable(attrs) {
					final V value = getValue(attrs);
					target.someMethod('value' and use annotation literals);
				} else {
					final V value = getDefault(attrs);
					target.someMethod('value' and use annotation literals);
				}
			}

			public void valueIsAvailable(TypedArray attrs) {
				// Variable implementation, generated by CallerComponentBuilder class
			}

			public V getValue(TypedArray attrs) {

			}

			public V getDefault(Context context, TypedArray attrs) {

			}
		}

		 */

		final MethodSpec valueIsAvailable = buildValueIsAvailableSpecFor(getValueHandlerAnnotation(e));

		final String nonUseParamType = getTypeOfNonUseParameter(e);

		final MethodSpec getValue = buildGetValueSpecFor(getValueHandlerAnnotation(e));
		final MethodSpec getDefault = buildGetDefaultValueSpecFor(getDefaultAnnotation(e));

		final MethodSpec callMethod = getCallMethodPartialSpec()
				.addCode(CodeBlock
						.builder()
						.addStatement("if ($N(attrs))", valueIsAvailable)
						.addStatement("$T value = ($T) $N(attrs)", nonUseParamType, nonUseParamType, getValue)
						.addStatement("$L.$L", "target", getInvocationLiteral(e, "value"))
						.nextControlFlow("else")
						.addStatement("$T value = ($T) $N(attrs, context)",
								nonUseParamType,
								nonUseParamType,
								getDefault)
						.addStatement("$L.$L", "target", getInvocationLiteral(e, "value"))
						.build())
				.build();

		return getCallerPartialSpec()
				.addMethod(callMethod)
				.addMethod(valueIsAvailable)
				.addMethod(getValue)
				.addMethod(getDefault)
				.build();
	}

	private TypeSpec.Builder getCallerPartialSpec() {
		final ClassName genericCaller = ClassName.get(CallerDef.PACKAGE, CallerDef.INTERFACE_NAME);
		final TypeName specificCaller = ParameterizedTypeName.get(genericCaller, targetClass);

		return TypeSpec
				.anonymousClassBuilder("")
				.addSuperinterface(specificCaller);
	}

	private MethodSpec.Builder getCallMethodPartialSpec() {
		return MethodSpec
				.methodBuilder(CallerDef.METHOD_NAME)
				.returns(void.class)
				.addModifiers(PUBLIC)
				.addParameter(targetClass, "target")
				.addParameter(AndroidClassDefinitions.CONTEXT, "context")
				.addParameter(AndroidClassDefinitions.TYPED_ARRAY, "attrs");
	}
}