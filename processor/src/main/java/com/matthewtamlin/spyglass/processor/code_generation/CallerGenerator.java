package com.matthewtamlin.spyglass.processor.code_generation;

import com.matthewtamlin.java_utilities.testing.Tested;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.util.Elements;

import static com.matthewtamlin.java_utilities.checkers.NullChecker.checkNotNull;
import static com.matthewtamlin.spyglass.processor.annotation_utils.CallHandlerAnnotationUtil.getCallHandlerAnnotationMirror;
import static com.matthewtamlin.spyglass.processor.annotation_utils.CallHandlerAnnotationUtil.hasCallHandlerAnnotation;
import static com.matthewtamlin.spyglass.processor.annotation_utils.DefaultAnnotationUtil.getDefaultAnnotationMirror;
import static com.matthewtamlin.spyglass.processor.annotation_utils.DefaultAnnotationUtil.hasDefaultAnnotation;
import static com.matthewtamlin.spyglass.processor.annotation_utils.UseAnnotationUtil.hasUseAnnotation;
import static com.matthewtamlin.spyglass.processor.annotation_utils.ValueHandlerAnnotationUtil.getValueHandlerAnnotationMirror;
import static com.matthewtamlin.spyglass.processor.annotation_utils.ValueHandlerAnnotationUtil.hasValueHandlerAnnotation;
import static javax.lang.model.element.Modifier.PUBLIC;

@Tested(testMethod = "automated")
public class CallerGenerator {
	private final GetDefaultMethodGenerator getDefaultMethodGenerator;

	private final GetValueMethodGenerator getValueMethodGenerator;

	private final ValueIsAvailableMethodGenerator valueIsAvailableMethodGenerator;

	private final SpecificValueIsAvailableMethodGenerator specificValueIsAvailableMethodGenerator;

	private final InvocationLiteralGenerator invocationLiteralGenerator;

	public CallerGenerator(final Elements elementUtil) {
		checkNotNull(elementUtil, "Argument \'elementUtil\' cannot be null.");

		getDefaultMethodGenerator = new GetDefaultMethodGenerator(elementUtil);
		getValueMethodGenerator = new GetValueMethodGenerator(elementUtil);
		valueIsAvailableMethodGenerator = new ValueIsAvailableMethodGenerator(elementUtil);
		specificValueIsAvailableMethodGenerator = new SpecificValueIsAvailableMethodGenerator(elementUtil);
		invocationLiteralGenerator = new InvocationLiteralGenerator(elementUtil);
	}

	public TypeSpec generateCaller(final ExecutableElement method) {
		checkNotNull(method, "Argument \'method\' cannot be null.");

		if (hasCallHandlerAnnotation(method)) {
			return generateCallHandlerCaller(method);

		} else if (hasValueHandlerAnnotation(method)) {
			return hasDefaultAnnotation(method) ?
					generateValueHandlerCallerWithDefault(method) :
					generateValueHandlerCallerWithoutDefault(method);

		} else {
			throw new IllegalArgumentException("Argument \'method\' has neither a value handler annotation nor a call" +
					" handler annotation.");
		}
	}

	/* General structure
	 *
	 * 	new Caller<T> {
	 * 		public void callMethod(final T target, final Context context, final TypedArray attrs) {
	 * 			if (specificValueIsAvailable(attrs) {
	 * 				target.<name of e>(<arguments generated from use annotations>)
	 * 			}
	 * 		}
	 *
	 *		public boolean specificValueIsAvailable(final TypedArray attrs) {
	 *			<dynamic method body>
	 *		}
	 * 	}
	 */
	private TypeSpec generateCallHandlerCaller(final ExecutableElement e) {
		final AnnotationMirror callHandlerAnno = getCallHandlerAnnotationMirror(e);
		final MethodSpec specificValueIsAvailable = specificValueIsAvailableMethodGenerator.getMethod(callHandlerAnno);

		final MethodSpec call = getEmptyCallMethod(getNameOfTargetClass(e))
				.addCode(CodeBlock
						.builder()
						.beginControlFlow("if ($N(attrs))", specificValueIsAvailable)
						.addStatement("$L.$L", "target", invocationLiteralGenerator.generateLiteralWithoutExtraArg(e))
						.endControlFlow()
						.build())
				.build();

		return getEmptyAnonymousCaller(getNameOfTargetClass(e))
				.addMethod(call)
				.addMethod(specificValueIsAvailable)
				.build();
	}

	/* General structure, where V is the type of the non-use parameter
	 *
	 * 	new Caller<T> {
	 *		public void call(final T target, final Context context, final TypedArray attrs) {
	 *			if (valueIsAvailable(attrs) {
	 *				<V> value = (<V>) getValue(attrs);
	 *
	 *				// Variable implementation, generated by invocationLiteralGenerator
	 *				target.<generated method call using "value">
	 *			}
	 *		}
	 *
	 *		public boolean valueIsAvailable(final TypedArray attrs) {
	 *			<dynamic method body>
	 *		}
	 *
	 *		public Object getValue(final TypedArray attrs) {
	 *			<dynamic method body>
	 *		}
	 * }
	 */
	private TypeSpec generateValueHandlerCallerWithoutDefault(final ExecutableElement e) {
		final AnnotationMirror valueHandlerAnno = getValueHandlerAnnotationMirror(e);
		final MethodSpec valueIsAvailable = valueIsAvailableMethodGenerator.getMethod(valueHandlerAnno);
		final MethodSpec getValue = getValueMethodGenerator.getMethod(valueHandlerAnno);

		final MethodSpec call = getEmptyCallMethod(getNameOfTargetClass(e))
				.addCode(CodeBlock
						.builder()
						.beginControlFlow("if ($N(attrs))", valueIsAvailable)
						.beginControlFlow(
								"if ((Object) $N(attrs) instanceof $T)",
								getValue,
								boxIfNecessary(getNameOfNonUseParameter(e)))
						.addStatement("final $1T value = ($1T) $2N(attrs)", getNameOfNonUseParameter(e), getValue)
						.addStatement(
								"$L.$L",
								"target",
								invocationLiteralGenerator.generateLiteralWithExtraArg(e, "value"))
						.nextControlFlow("else")
						.addStatement("throw new $T()", ClassName.get(RuntimeException.class))
						.endControlFlow()
						.endControlFlow()

						.build())
				.build();

		return getEmptyAnonymousCaller(getNameOfTargetClass(e))
				.addMethod(call)
				.addMethod(valueIsAvailable)
				.addMethod(getValue)
				.build();
	}

	/* General structure, where V is the type of the non-use parameter
	 *
	 * 	new Caller<T> {
	 *		public void callMethod(T target, Context context, TypedArray attrs) {
	 *			<V> value = valueIsAvailable(attrs) ? (<V>) getValue(attrs) : (<V>) getDefault(attrs);
	 *			doInvocation(target, value);
	 *		}
	 *
	 *		public boolean valueIsAvailable(TypedArray attrs) {
	 *			// Variable implementation, generated by callerComponentGenerator
	 *			<generated boolean with return>
	 *		}
	 *
	 *		public Object getValue(TypedArray attrs) {
	 *			// Variable implementation, generated by callerComponentGenerator
	 *			<generated code with return>
	 *		}
	 *
	 *		public Object getDefault(Context context, TypedArray attrs) {
	 *			// Variable implementation, generated by callerComponentGenerator
	 *			<generated code with return>
	 *		}
	 *
	 * 		public void doInvocation(T target, V value) {
	 * 			target.<methodname>(<value and use args>)
	 * 		}
	 *	}
	 */
	private TypeSpec generateValueHandlerCallerWithDefault(final ExecutableElement e) {
		final AnnotationMirror valueHandler = getValueHandlerAnnotationMirror(e);
		final MethodSpec valueIsAvailable = valueIsAvailableMethodGenerator.getMethod(valueHandler);
		final MethodSpec getValue = getValueMethodGenerator.getMethod(valueHandler);

		final AnnotationMirror defaultAnno = getDefaultAnnotationMirror(e);
		final MethodSpec getDefault = getDefaultMethodGenerator.getMethod(defaultAnno);

		final MethodSpec callMethod = getEmptyCallMethod(getNameOfTargetClass(e))
				.addCode(CodeBlock
						.builder()
						.beginControlFlow("if ($N(attrs))", valueIsAvailable)
						.beginControlFlow(
								"if ((Object) $N(attrs) instanceof $T)",
								getValue,
								boxIfNecessary(getNameOfNonUseParameter(e)))
						.addStatement("final $1T value = ($1T) $2N(attrs)", getNameOfNonUseParameter(e), getValue)
						.addStatement("target.$L", invocationLiteralGenerator.generateLiteralWithExtraArg(e, "value"))
						.nextControlFlow("else")
						.addStatement("throw new $T()", ClassName.get(RuntimeException.class))
						.endControlFlow()
						.nextControlFlow("else")
						.beginControlFlow(
								"if ((Object) $N(context, attrs) instanceof $T)",
								getDefault,
								boxIfNecessary(getNameOfNonUseParameter(e)))
						.addStatement(
								"final $1T value = ($1T) $2N(context, attrs)",
								getNameOfNonUseParameter(e),
								getDefault)
						.addStatement("target.$L", invocationLiteralGenerator.generateLiteralWithExtraArg(e, "value"))
						.nextControlFlow("else")
						.addStatement("throw new $T()", ClassName.get(RuntimeException.class))
						.endControlFlow()
						.endControlFlow()
						.build())
				.build();

		return getEmptyAnonymousCaller(getNameOfTargetClass(e))
				.addMethod(callMethod)
				.addMethod(valueIsAvailable)
				.addMethod(getValue)
				.addMethod(getDefault)
				.build();
	}

	private TypeSpec.Builder getEmptyAnonymousCaller(final TypeName targetType) {
		final ClassName genericCaller = ClassName.get(CallerDef.PACKAGE, CallerDef.INTERFACE_NAME);
		final TypeName specificCaller = ParameterizedTypeName.get(genericCaller, targetType);

		return TypeSpec
				.anonymousClassBuilder("")
				.addSuperinterface(specificCaller);
	}

	private MethodSpec.Builder getEmptyCallMethod(final TypeName targetType) {
		return MethodSpec
				.methodBuilder(CallerDef.METHOD_NAME)
				.returns(void.class)
				.addModifiers(PUBLIC)
				.addParameter(targetType, "target")
				.addParameter(AndroidClassNames.CONTEXT, "context")
				.addParameter(AndroidClassNames.TYPED_ARRAY, "attrs");
	}

	private TypeName getNameOfNonUseParameter(final ExecutableElement e) {
		for (final VariableElement parameter : e.getParameters()) {
			if (!hasUseAnnotation(parameter)) {
				final TypeName className = ClassName.get(parameter.asType());

				if (className.isBoxedPrimitive()) {
					return className.unbox();
				} else {
					return className;
				}
			}
		}

		throw new RuntimeException("No non-use argument found.");
	}

	private TypeName getNameOfTargetClass(final ExecutableElement method) {
		final TypeElement enclosingType = (TypeElement) method.getEnclosingElement();
		return TypeName.get(enclosingType.asType());
	}

	private TypeName boxIfNecessary(final TypeName typeName) {
		if (typeName.isPrimitive()) {
			return typeName.box();
		} else {
			return typeName;
		}
	}
}